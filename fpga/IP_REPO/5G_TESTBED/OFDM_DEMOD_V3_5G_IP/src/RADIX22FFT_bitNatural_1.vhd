-- -------------------------------------------------------------
-- 
-- File Name: hdlsrc\FFTHDLOptimizedExample_Streaming\RADIX22FFT_bitNatural_1.vhd
-- Created: 2022-05-04 13:42:43
-- 
-- Generated by MATLAB 9.11 and HDL Coder 3.19
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: RADIX22FFT_bitNatural_1
-- Source Path: FFTHDLOptimizedExample_Streaming/FFT HDL Optimized Streaming/FFT HDL Optimized/RADIX22FFT_bitNatural_1
-- Hierarchy Level: 2
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.FFT_HDL_Optimized_Streaming_pkg.ALL;

ENTITY RADIX22FFT_bitNatural_1 IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        dout_re_v                         :   IN    vector_of_std_logic_vector27(0 TO 1);  -- sfix27_En13 [2]
        dout_im_v                         :   IN    vector_of_std_logic_vector27(0 TO 1);  -- sfix27_En13 [2]
        dout_2_vld                        :   IN    std_logic;
        dMem_re1                          :   OUT   std_logic_vector(26 DOWNTO 0);  -- sfix27_En13
        dMem_im1                          :   OUT   std_logic_vector(26 DOWNTO 0);  -- sfix27_En13
        dMem_vld1                         :   OUT   std_logic
        );
END RADIX22FFT_bitNatural_1;


ARCHITECTURE rtl OF RADIX22FFT_bitNatural_1 IS

  -- Component Declarations
  COMPONENT SimpleDualPortRAM_generic
    GENERIC( AddrWidth                    : integer;
             DataWidth                    : integer
             );
    PORT( clk                             :   IN    std_logic;
          wr_din                          :   IN    std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          wr_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          wr_en                           :   IN    std_logic;
          rd_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          rd_dout                         :   OUT   std_logic_vector(DataWidth - 1 DOWNTO 0)  -- generic width
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : SimpleDualPortRAM_generic
    USE ENTITY work.SimpleDualPortRAM_generic(rtl);

  -- Functions
  -- HDLCODER_TO_STDLOGIC 
  FUNCTION hdlcoder_to_stdlogic(arg: boolean) RETURN std_logic IS
  BEGIN
    IF arg THEN
      RETURN '1';
    ELSE
      RETURN '0';
    END IF;
  END FUNCTION;


  -- Signals
  SIGNAL fftIdx_cnt                       : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL fftIdx_cnt_next                  : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL FFTIdx_1                         : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL FFTIdxRev                        : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL fftIdx_vld                       : std_logic;
  SIGNAL wrAddrGenBitNaturalP_wrCnt       : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL wrAddrGenBitNaturalP_wrOddFrame  : std_logic;
  SIGNAL wrAddrGenBitNaturalP_wrAddrReg   : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL wrAddrGenBitNaturalP_wrEnbReg    : std_logic;
  SIGNAL wrAddrGenBitNaturalP_wrCnt_next  : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL wrAddrGenBitNaturalP_wrOddFrame_next : std_logic;
  SIGNAL wrAddrGenBitNaturalP_wrAddrReg_next : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL wrAddrGenBitNaturalP_wrEnbReg_next : std_logic;
  SIGNAL wrAddr                           : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL WrEnb                            : std_logic;
  SIGNAL sampleCnt                        : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL intdelay_reg                     : vector_of_unsigned10(0 TO 1);  -- ufix10 [2]
  SIGNAL sampleCntDly                     : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL MUXSel                           : std_logic;  -- ufix1
  SIGNAL MUXSel_vld                       : std_logic;
  SIGNAL dout_re_v_0                      : signed(26 DOWNTO 0);  -- sfix27_En13
  SIGNAL din_re_reg1                      : signed(26 DOWNTO 0);  -- sfix27_En13
  SIGNAL dout_re_v_1                      : signed(26 DOWNTO 0);  -- sfix27_En13
  SIGNAL din_re_reg2                      : signed(26 DOWNTO 0);  -- sfix27_En13
  SIGNAL memIn_re                         : signed(26 DOWNTO 0);  -- sfix27_En13
  SIGNAL memIn_re_reg                     : signed(26 DOWNTO 0);  -- sfix27_En13
  SIGNAL wrAddr_reg                       : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL wrEnb_reg                        : std_logic;
  SIGNAL dout_im_v_0                      : signed(26 DOWNTO 0);  -- sfix27_En13
  SIGNAL din_im_reg1                      : signed(26 DOWNTO 0);  -- sfix27_En13
  SIGNAL dout_im_v_1                      : signed(26 DOWNTO 0);  -- sfix27_En13
  SIGNAL din_im_reg2                      : signed(26 DOWNTO 0);  -- sfix27_En13
  SIGNAL memIn_im                         : signed(26 DOWNTO 0);  -- sfix27_En13
  SIGNAL memIn_im_reg                     : signed(26 DOWNTO 0);  -- sfix27_En13
  SIGNAL rdAddr                           : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL memOut_im                        : std_logic_vector(26 DOWNTO 0);  -- ufix27
  SIGNAL memOut_im_signed                 : signed(26 DOWNTO 0);  -- sfix27_En13
  SIGNAL memOut_re                        : std_logic_vector(26 DOWNTO 0);  -- ufix27
  SIGNAL memOut_re_signed                 : signed(26 DOWNTO 0);  -- sfix27_En13
  SIGNAL rdAddrGenBitNaturalP_addrReg     : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL rdAddrGenBitNaturalP_rdOddFrame  : std_logic;
  SIGNAL rdAddrGenBitNaturalP_rdAddrReg   : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL rdAddrGenBitNaturalP_rdState     : std_logic;  -- ufix1
  SIGNAL rdAddrGenBitNaturalP_vldOutReg   : std_logic;
  SIGNAL rdAddrGenBitNaturalP_rdCnt       : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL rdAddrGenBitNaturalP_FFTIdxO     : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL rdAddrGenBitNaturalP_startOutReg : std_logic;
  SIGNAL rdAddrGenBitNaturalP_endOutReg   : std_logic;
  SIGNAL rdAddrGenBitNaturalP_startOutRegDly : std_logic;
  SIGNAL rdAddrGenBitNaturalP_endOutRegDly : std_logic;
  SIGNAL rdAddrGenBitNaturalP_addrReg_next : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL rdAddrGenBitNaturalP_rdOddFrame_next : std_logic;
  SIGNAL rdAddrGenBitNaturalP_rdAddrReg_next : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL rdAddrGenBitNaturalP_rdState_next : std_logic;  -- ufix1
  SIGNAL rdAddrGenBitNaturalP_vldOutReg_next : std_logic;
  SIGNAL rdAddrGenBitNaturalP_rdCnt_next  : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL rdAddrGenBitNaturalP_FFTIdxO_next : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL rdAddrGenBitNaturalP_startOutReg_next : std_logic;
  SIGNAL rdAddrGenBitNaturalP_endOutReg_next : std_logic;
  SIGNAL rdAddrGenBitNaturalP_startOutRegDly_next : std_logic;
  SIGNAL rdAddrGenBitNaturalP_endOutRegDly_next : std_logic;
  SIGNAL dMem_re1_tmp                     : signed(26 DOWNTO 0);  -- sfix27_En13
  SIGNAL dMem_im1_tmp                     : signed(26 DOWNTO 0);  -- sfix27_En13
  SIGNAL startOutW                        : std_logic;
  SIGNAL endOutW                          : std_logic;

BEGIN
  u_dataMEM_im_0 : SimpleDualPortRAM_generic
    GENERIC MAP( AddrWidth => 10,
                 DataWidth => 27
                 )
    PORT MAP( clk => clk,
              wr_din => std_logic_vector(memIn_im_reg),
              wr_addr => std_logic_vector(wrAddr_reg),
              wr_en => wrEnb_reg,
              rd_addr => std_logic_vector(rdAddr),
              rd_dout => memOut_im
              );

  u_dataMEM_re_0 : SimpleDualPortRAM_generic
    GENERIC MAP( AddrWidth => 10,
                 DataWidth => 27
                 )
    PORT MAP( clk => clk,
              wr_din => std_logic_vector(memIn_re_reg),
              wr_addr => std_logic_vector(wrAddr_reg),
              wr_en => wrEnb_reg,
              rd_addr => std_logic_vector(rdAddr),
              rd_dout => memOut_re
              );

  -- fftIdx
  fftIdx_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      fftIdx_cnt <= to_unsigned(16#000#, 11);
    ELSIF clk'EVENT AND clk = '1' THEN
      fftIdx_cnt <= fftIdx_cnt_next;
    END IF;
  END PROCESS fftIdx_process;

  fftIdx_output : PROCESS (dout_2_vld, fftIdx_cnt)
  BEGIN
    fftIdx_cnt_next <= fftIdx_cnt;
    IF dout_2_vld = '1' THEN 
      fftIdx_cnt_next <= fftIdx_cnt + to_unsigned(16#002#, 11);
    END IF;
    FFTIdx_1 <= fftIdx_cnt;
    FFTIdxRev <= unsigned'(fftIdx_cnt(0) & fftIdx_cnt(1) & fftIdx_cnt(2) & fftIdx_cnt(3) & fftIdx_cnt(4) & fftIdx_cnt(5) & fftIdx_cnt(6) & fftIdx_cnt(7) & fftIdx_cnt(8) & fftIdx_cnt(9) & fftIdx_cnt(10));
    fftIdx_vld <= dout_2_vld;
  END PROCESS fftIdx_output;


  -- wrAddrGenBitNaturalP
  wrAddrGenBitNaturalP_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      wrAddrGenBitNaturalP_wrCnt <= to_unsigned(16#000#, 10);
      wrAddrGenBitNaturalP_wrAddrReg <= to_unsigned(16#000#, 10);
      wrAddrGenBitNaturalP_wrOddFrame <= '0';
      wrAddrGenBitNaturalP_wrEnbReg <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      wrAddrGenBitNaturalP_wrCnt <= wrAddrGenBitNaturalP_wrCnt_next;
      wrAddrGenBitNaturalP_wrOddFrame <= wrAddrGenBitNaturalP_wrOddFrame_next;
      wrAddrGenBitNaturalP_wrAddrReg <= wrAddrGenBitNaturalP_wrAddrReg_next;
      wrAddrGenBitNaturalP_wrEnbReg <= wrAddrGenBitNaturalP_wrEnbReg_next;
    END IF;
  END PROCESS wrAddrGenBitNaturalP_process;

  wrAddrGenBitNaturalP_output : PROCESS (FFTIdxRev, fftIdx_vld, wrAddrGenBitNaturalP_wrAddrReg,
       wrAddrGenBitNaturalP_wrCnt, wrAddrGenBitNaturalP_wrEnbReg,
       wrAddrGenBitNaturalP_wrOddFrame)
  BEGIN
    wrAddrGenBitNaturalP_wrCnt_next <= wrAddrGenBitNaturalP_wrCnt;
    wrAddrGenBitNaturalP_wrOddFrame_next <= wrAddrGenBitNaturalP_wrOddFrame;
    wrAddrGenBitNaturalP_wrAddrReg_next <= wrAddrGenBitNaturalP_wrAddrReg;
    wrAddrGenBitNaturalP_wrEnbReg_next <= fftIdx_vld;
    IF wrAddrGenBitNaturalP_wrOddFrame = '1' THEN 
      wrAddrGenBitNaturalP_wrAddrReg_next <= wrAddrGenBitNaturalP_wrCnt;
    ELSE 
      wrAddrGenBitNaturalP_wrAddrReg_next <= FFTIdxRev(10 DOWNTO 1) + unsigned'(FFTIdxRev(0) & "000000000");
    END IF;
    IF (hdlcoder_to_stdlogic(wrAddrGenBitNaturalP_wrCnt = to_unsigned(16#3FF#, 10)) AND fftIdx_vld) = '1' THEN 
      wrAddrGenBitNaturalP_wrOddFrame_next <=  NOT wrAddrGenBitNaturalP_wrOddFrame;
    END IF;
    IF fftIdx_vld = '1' THEN 
      wrAddrGenBitNaturalP_wrCnt_next <= wrAddrGenBitNaturalP_wrCnt + to_unsigned(16#001#, 10);
    END IF;
    wrAddr <= wrAddrGenBitNaturalP_wrAddrReg;
    WrEnb <= wrAddrGenBitNaturalP_wrEnbReg;
    sampleCnt <= wrAddrGenBitNaturalP_wrCnt;
  END PROCESS wrAddrGenBitNaturalP_output;


  intdelay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      intdelay_reg <= (OTHERS => to_unsigned(16#000#, 10));
    ELSIF clk'EVENT AND clk = '1' THEN
      intdelay_reg(0) <= sampleCnt;
      intdelay_reg(1) <= intdelay_reg(0);
    END IF;
  END PROCESS intdelay_process;

  sampleCntDly <= intdelay_reg(1);

  -- inMUXSel
  inMuxSel_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      MUXSel <= '0';
      MUXSel_vld <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      MUXSel <= FFTIdxRev(0);
      MUXSel_vld <= fftIdx_vld;
    END IF;
  END PROCESS inMuxSel_process;


  dout_re_v_0 <= signed(dout_re_v(0));

  intdelay_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      din_re_reg1 <= to_signed(16#0000000#, 27);
    ELSIF clk'EVENT AND clk = '1' THEN
      din_re_reg1 <= dout_re_v_0;
    END IF;
  END PROCESS intdelay_1_process;


  dout_re_v_1 <= signed(dout_re_v(1));

  intdelay_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      din_re_reg2 <= to_signed(16#0000000#, 27);
    ELSIF clk'EVENT AND clk = '1' THEN
      din_re_reg2 <= dout_re_v_1;
    END IF;
  END PROCESS intdelay_2_process;


  
  memIn_re <= din_re_reg1 WHEN MUXSel = '0' ELSE
      din_re_reg2;

  intdelay_3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      memIn_re_reg <= to_signed(16#0000000#, 27);
    ELSIF clk'EVENT AND clk = '1' THEN
      memIn_re_reg <= memIn_re;
    END IF;
  END PROCESS intdelay_3_process;


  intdelay_4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      wrAddr_reg <= to_unsigned(16#000#, 10);
    ELSIF clk'EVENT AND clk = '1' THEN
      wrAddr_reg <= wrAddr;
    END IF;
  END PROCESS intdelay_4_process;


  intdelay_5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      wrEnb_reg <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      wrEnb_reg <= WrEnb;
    END IF;
  END PROCESS intdelay_5_process;


  dout_im_v_0 <= signed(dout_im_v(0));

  intdelay_6_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      din_im_reg1 <= to_signed(16#0000000#, 27);
    ELSIF clk'EVENT AND clk = '1' THEN
      din_im_reg1 <= dout_im_v_0;
    END IF;
  END PROCESS intdelay_6_process;


  dout_im_v_1 <= signed(dout_im_v(1));

  intdelay_7_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      din_im_reg2 <= to_signed(16#0000000#, 27);
    ELSIF clk'EVENT AND clk = '1' THEN
      din_im_reg2 <= dout_im_v_1;
    END IF;
  END PROCESS intdelay_7_process;


  
  memIn_im <= din_im_reg1 WHEN MUXSel = '0' ELSE
      din_im_reg2;

  intdelay_8_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      memIn_im_reg <= to_signed(16#0000000#, 27);
    ELSIF clk'EVENT AND clk = '1' THEN
      memIn_im_reg <= memIn_im;
    END IF;
  END PROCESS intdelay_8_process;


  memOut_im_signed <= signed(memOut_im);

  memOut_re_signed <= signed(memOut_re);

  -- rdAddrGenBitNaturalP
  rdAddrGenBitNaturalP_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      rdAddrGenBitNaturalP_addrReg <= to_unsigned(16#000#, 10);
      rdAddrGenBitNaturalP_rdCnt <= to_unsigned(16#000#, 10);
      rdAddrGenBitNaturalP_rdAddrReg <= to_unsigned(16#000#, 10);
      rdAddrGenBitNaturalP_rdOddFrame <= '0';
      rdAddrGenBitNaturalP_vldOutReg <= '0';
      rdAddrGenBitNaturalP_rdState <= '0';
      rdAddrGenBitNaturalP_FFTIdxO <= to_unsigned(16#000#, 11);
      rdAddrGenBitNaturalP_startOutReg <= '0';
      rdAddrGenBitNaturalP_endOutReg <= '0';
      rdAddrGenBitNaturalP_startOutRegDly <= '0';
      rdAddrGenBitNaturalP_endOutRegDly <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      rdAddrGenBitNaturalP_addrReg <= rdAddrGenBitNaturalP_addrReg_next;
      rdAddrGenBitNaturalP_rdOddFrame <= rdAddrGenBitNaturalP_rdOddFrame_next;
      rdAddrGenBitNaturalP_rdAddrReg <= rdAddrGenBitNaturalP_rdAddrReg_next;
      rdAddrGenBitNaturalP_rdState <= rdAddrGenBitNaturalP_rdState_next;
      rdAddrGenBitNaturalP_vldOutReg <= rdAddrGenBitNaturalP_vldOutReg_next;
      rdAddrGenBitNaturalP_rdCnt <= rdAddrGenBitNaturalP_rdCnt_next;
      rdAddrGenBitNaturalP_FFTIdxO <= rdAddrGenBitNaturalP_FFTIdxO_next;
      rdAddrGenBitNaturalP_startOutReg <= rdAddrGenBitNaturalP_startOutReg_next;
      rdAddrGenBitNaturalP_endOutReg <= rdAddrGenBitNaturalP_endOutReg_next;
      rdAddrGenBitNaturalP_startOutRegDly <= rdAddrGenBitNaturalP_startOutRegDly_next;
      rdAddrGenBitNaturalP_endOutRegDly <= rdAddrGenBitNaturalP_endOutRegDly_next;
    END IF;
  END PROCESS rdAddrGenBitNaturalP_process;

  rdAddrGenBitNaturalP_output : PROCESS (memOut_im_signed, memOut_re_signed, rdAddrGenBitNaturalP_FFTIdxO,
       rdAddrGenBitNaturalP_addrReg, rdAddrGenBitNaturalP_endOutReg,
       rdAddrGenBitNaturalP_endOutRegDly, rdAddrGenBitNaturalP_rdAddrReg,
       rdAddrGenBitNaturalP_rdCnt, rdAddrGenBitNaturalP_rdOddFrame,
       rdAddrGenBitNaturalP_rdState, rdAddrGenBitNaturalP_startOutReg,
       rdAddrGenBitNaturalP_startOutRegDly, rdAddrGenBitNaturalP_vldOutReg,
       sampleCntDly)
    VARIABLE c : unsigned(10 DOWNTO 0);
  BEGIN
    rdAddrGenBitNaturalP_addrReg_next <= rdAddrGenBitNaturalP_addrReg;
    rdAddrGenBitNaturalP_FFTIdxO_next <= rdAddrGenBitNaturalP_FFTIdxO;
    rdAddrGenBitNaturalP_rdOddFrame_next <= rdAddrGenBitNaturalP_rdOddFrame;
    rdAddrGenBitNaturalP_rdAddrReg_next <= rdAddrGenBitNaturalP_rdAddrReg;
    rdAddrGenBitNaturalP_rdState_next <= rdAddrGenBitNaturalP_rdState;
    rdAddrGenBitNaturalP_vldOutReg_next <= rdAddrGenBitNaturalP_vldOutReg;
    rdAddrGenBitNaturalP_rdCnt_next <= rdAddrGenBitNaturalP_rdCnt;
    rdAddrGenBitNaturalP_startOutReg_next <= rdAddrGenBitNaturalP_startOutReg;
    rdAddrGenBitNaturalP_endOutReg_next <= rdAddrGenBitNaturalP_endOutReg;
    rdAddrGenBitNaturalP_startOutRegDly_next <= rdAddrGenBitNaturalP_startOutReg;
    rdAddrGenBitNaturalP_endOutRegDly_next <= rdAddrGenBitNaturalP_endOutReg;
    c := unsigned'(rdAddrGenBitNaturalP_FFTIdxO(0) & rdAddrGenBitNaturalP_FFTIdxO(1) & rdAddrGenBitNaturalP_FFTIdxO(2) & rdAddrGenBitNaturalP_FFTIdxO(3) & rdAddrGenBitNaturalP_FFTIdxO(4) & rdAddrGenBitNaturalP_FFTIdxO(5) & rdAddrGenBitNaturalP_FFTIdxO(6) & rdAddrGenBitNaturalP_FFTIdxO(7) & rdAddrGenBitNaturalP_FFTIdxO(8) & rdAddrGenBitNaturalP_FFTIdxO(9) & rdAddrGenBitNaturalP_FFTIdxO(10));
    IF rdAddrGenBitNaturalP_rdOddFrame = '1' THEN 
      rdAddrGenBitNaturalP_rdAddrReg_next <= c(10 DOWNTO 1) + unsigned'(c(0) & "000000000");
    ELSE 
      rdAddrGenBitNaturalP_rdAddrReg_next <= rdAddrGenBitNaturalP_addrReg;
    END IF;
    CASE rdAddrGenBitNaturalP_rdState IS
      WHEN '0' =>
        rdAddrGenBitNaturalP_rdState_next <= '0';
        rdAddrGenBitNaturalP_endOutReg_next <= '0';
        rdAddrGenBitNaturalP_rdCnt_next <= to_unsigned(16#000#, 10);
        rdAddrGenBitNaturalP_addrReg_next <= to_unsigned(16#000#, 10);
        rdAddrGenBitNaturalP_vldOutReg_next <= '0';
        rdAddrGenBitNaturalP_startOutReg_next <= '0';
        rdAddrGenBitNaturalP_FFTIdxO_next <= to_unsigned(16#000#, 11);
        IF sampleCntDly = to_unsigned(16#3FF#, 10) THEN 
          rdAddrGenBitNaturalP_rdState_next <= '1';
          rdAddrGenBitNaturalP_addrReg_next <= to_unsigned(16#001#, 10);
          rdAddrGenBitNaturalP_FFTIdxO_next <= to_unsigned(16#002#, 11);
          rdAddrGenBitNaturalP_startOutReg_next <= '1';
        END IF;
      WHEN '1' =>
        rdAddrGenBitNaturalP_rdState_next <= '1';
        rdAddrGenBitNaturalP_endOutReg_next <= '0';
        rdAddrGenBitNaturalP_startOutReg_next <= '0';
        rdAddrGenBitNaturalP_vldOutReg_next <= '1';
        IF rdAddrGenBitNaturalP_rdCnt = to_unsigned(16#3FF#, 10) THEN 
          IF sampleCntDly = to_unsigned(16#3FF#, 10) THEN 
            rdAddrGenBitNaturalP_rdState_next <= '1';
            rdAddrGenBitNaturalP_startOutReg_next <= '1';
            rdAddrGenBitNaturalP_FFTIdxO_next <= rdAddrGenBitNaturalP_FFTIdxO + to_unsigned(16#002#, 11);
            rdAddrGenBitNaturalP_addrReg_next <= rdAddrGenBitNaturalP_addrReg + to_unsigned(16#001#, 10);
          ELSE 
            rdAddrGenBitNaturalP_rdState_next <= '0';
            rdAddrGenBitNaturalP_FFTIdxO_next <= to_unsigned(16#000#, 11);
            rdAddrGenBitNaturalP_addrReg_next <= to_unsigned(16#000#, 10);
          END IF;
        ELSE 
          rdAddrGenBitNaturalP_FFTIdxO_next <= rdAddrGenBitNaturalP_FFTIdxO + to_unsigned(16#002#, 11);
          rdAddrGenBitNaturalP_addrReg_next <= rdAddrGenBitNaturalP_addrReg + to_unsigned(16#001#, 10);
        END IF;
        IF rdAddrGenBitNaturalP_rdCnt = to_unsigned(16#3FE#, 10) THEN 
          rdAddrGenBitNaturalP_endOutReg_next <= '1';
          rdAddrGenBitNaturalP_rdOddFrame_next <=  NOT rdAddrGenBitNaturalP_rdOddFrame;
        END IF;
        rdAddrGenBitNaturalP_rdCnt_next <= rdAddrGenBitNaturalP_rdCnt + to_unsigned(16#001#, 10);
      WHEN OTHERS => 
        NULL;
    END CASE;
    rdAddr <= rdAddrGenBitNaturalP_rdAddrReg;
    dMem_re1_tmp <= memOut_re_signed;
    dMem_im1_tmp <= memOut_im_signed;
    dMem_vld1 <= rdAddrGenBitNaturalP_vldOutReg;
    startOutW <= rdAddrGenBitNaturalP_startOutRegDly;
    endOutW <= rdAddrGenBitNaturalP_endOutRegDly;
  END PROCESS rdAddrGenBitNaturalP_output;


  dMem_re1 <= std_logic_vector(dMem_re1_tmp);

  dMem_im1 <= std_logic_vector(dMem_im1_tmp);

END rtl;

