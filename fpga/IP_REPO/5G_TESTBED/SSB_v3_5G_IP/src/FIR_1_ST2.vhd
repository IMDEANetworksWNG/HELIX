-- -------------------------------------------------------------
-- 
-- File Name: hdlsrc\nrhdlSSBDetectionFR1Core\FIR_1.vhd
-- Created: 2021-11-30 13:30:52
-- 
-- Generated by MATLAB 9.10 and HDL Coder 3.18
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: FIR_1
-- Source Path: nrhdlSSBDetectionFR1Core/ssbDetectionCore/Frequency Correction and DDC/DDC/FR1/Stage 2/FIR 1
-- Hierarchy Level: 1
-- 
-- Discrete FIR Filter HDL Optimized
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.Stage_2_pkg.ALL;

ENTITY FIR_1_ST2 IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        dataIn_re                         :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
        dataIn_im                         :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
        validIn                           :   IN    std_logic;
        dataOut_re                        :   OUT   std_logic_vector(31 DOWNTO 0);  -- sfix32_En31
        dataOut_im                        :   OUT   std_logic_vector(31 DOWNTO 0);  -- sfix32_En31
        validOut                          :   OUT   std_logic
        );
END FIR_1_ST2;


ARCHITECTURE rtl OF FIR_1_ST2 IS

  -- Component Declarations
  COMPONENT FirRdyLogic_ST2
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          dataIn_re                       :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          dataIn_im                       :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          validIn                         :   IN    std_logic;
          din_re                          :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          din_im                          :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          dinVld                          :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT Addressable_Delay_Line_ST2
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          dataIn                          :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          validIn                         :   IN    std_logic;
          shiftEn                         :   IN    std_logic;
          rdAddr                          :   IN    std_logic;  -- ufix1
          delayLineEnd                    :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          dataOut                         :   OUT   std_logic_vector(15 DOWNTO 0)  -- sfix16_En15
          );
  END COMPONENT;

  COMPONENT Addressable_Delay_Line_block_ST2
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          dataIn                          :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          validIn                         :   IN    std_logic;
          shiftEn                         :   IN    std_logic;
          rdAddr                          :   IN    std_logic;  -- ufix1
          dataOut                         :   OUT   std_logic_vector(15 DOWNTO 0)  -- sfix16_En15
          );
  END COMPONENT;

  COMPONENT FilterTapSystolicPreAdd_ST2
    PORT( clk                             :   IN    std_logic;
          enb                             :   IN    std_logic;
          din_re                          :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          preAddIn                        :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          coeff                           :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En16
          sumIn                           :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En31
          sumOut                          :   OUT   std_logic_vector(31 DOWNTO 0)  -- sfix32_En31
          );
  END COMPONENT;

  COMPONENT Addressable_Delay_Line_block1_ST2
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          dataIn                          :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          validIn                         :   IN    std_logic;
          shiftEn                         :   IN    std_logic;
          rdAddr                          :   IN    std_logic;  -- ufix1
          delayLineEnd                    :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          dataOut                         :   OUT   std_logic_vector(15 DOWNTO 0)  -- sfix16_En15
          );
  END COMPONENT;

  COMPONENT Addressable_Delay_Line_block2_ST2
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          dataIn                          :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          validIn                         :   IN    std_logic;
          shiftEn                         :   IN    std_logic;
          rdAddr                          :   IN    std_logic;  -- ufix1
          dataOut                         :   OUT   std_logic_vector(15 DOWNTO 0)  -- sfix16_En15
          );
  END COMPONENT;

  COMPONENT FilterTapSystolicPreAdd_block_ST2
    PORT( clk                             :   IN    std_logic;
          enb                             :   IN    std_logic;
          din_im                          :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          preAddIn                        :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          coeff                           :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En16
          sumIn                           :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En31
          sumOut                          :   OUT   std_logic_vector(31 DOWNTO 0)  -- sfix32_En31
          );
  END COMPONENT;

--  -- Component Configuration Statements
--  FOR ALL : FirRdyLogic_ST2
--    USE ENTITY work.FirRdyLogic_ST2(rtl);

--  FOR ALL : Addressable_Delay_Line_ST2
--    USE ENTITY work.Addressable_Delay_Line_ST2(rtl);

--  FOR ALL : Addressable_Delay_Line_block_ST2
--    USE ENTITY work.Addressable_Delay_Line_block_ST2(rtl);

--  FOR ALL : FilterTapSystolicPreAdd_ST2
--    USE ENTITY work.FilterTapSystolicPreAdd_ST2(rtl);

--  FOR ALL : Addressable_Delay_Line_block1_ST2
--    USE ENTITY work.Addressable_Delay_Line_block1_ST2(rtl);

--  FOR ALL : Addressable_Delay_Line_block2_ST2
--    USE ENTITY work.Addressable_Delay_Line_block2_ST2(rtl);

--  FOR ALL : FilterTapSystolicPreAdd_block_ST2
--    USE ENTITY work.FilterTapSystolicPreAdd_block_ST2(rtl);

  -- Functions
  -- HDLCODER_TO_STDLOGIC 
  FUNCTION hdlcoder_to_stdlogic(arg: boolean) RETURN std_logic IS
  BEGIN
    IF arg THEN
      RETURN '1';
    ELSE
      RETURN '0';
    END IF;
  END FUNCTION;


  -- Signals
  SIGNAL din_re                           : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL din_im                           : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL dinVld                           : std_logic;
  SIGNAL nextSharingCount                 : std_logic;  -- ufix1
  SIGNAL sharingCount_1                   : std_logic;  -- ufix1
  SIGNAL delayLineValidIn0                : std_logic;
  SIGNAL lastPhaseStrobe                  : std_logic;
  SIGNAL delayLineShiftEn0_1              : std_logic;
  SIGNAL delayLineShiftEn1_1              : std_logic;
  SIGNAL validOutLookahead_reg            : std_logic_vector(0 TO 4);  -- ufix1 [5]
  SIGNAL validOutLookahead_1              : std_logic;
  SIGNAL rdAddr0_1                        : std_logic;  -- ufix1
  SIGNAL delayLineEnd0                    : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL delayLineDataOut0                : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL delayLineEnd0_signed             : signed(15 DOWNTO 0);  -- sfix16_En15
  SIGNAL delayLineDataIn1_1               : signed(15 DOWNTO 0);  -- sfix16_En15
  SIGNAL rdAddr1                          : std_logic;  -- ufix1
  SIGNAL delayLineDataOut1                : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL coeffTableOut0                   : signed(15 DOWNTO 0);  -- sfix16_En16
  SIGNAL coeffTableReg0_reg               : vector_of_signed16(0 TO 1);  -- sfix16 [2]
  SIGNAL coeffTableReg0_1                 : signed(15 DOWNTO 0);  -- sfix16_En16
  SIGNAL finalSumValidPipe_reg            : std_logic_vector(0 TO 3);  -- ufix1 [4]
  SIGNAL accumulate                       : std_logic;
  SIGNAL accDataOut                       : signed(31 DOWNTO 0);  -- sfix32_En31
  SIGNAL sumOut_signed                    : signed(31 DOWNTO 0);  -- sfix32_En31
  SIGNAL accSwitchOut                     : signed(31 DOWNTO 0);  -- sfix32_En31
  SIGNAL sumOut                           : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL dout_re_1                        : signed(31 DOWNTO 0);  -- sfix32_En31
  SIGNAL validOutLookahead_reg_1          : std_logic_vector(0 TO 4);  -- ufix1 [5]
  SIGNAL validOutLookahead_3              : std_logic;
  SIGNAL delayLineEnd0_1                  : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL delayLineDataOut0_1              : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL delayLineEnd0_signed_1           : signed(15 DOWNTO 0);  -- sfix16_En15
  SIGNAL delayLineDataIn1_3               : signed(15 DOWNTO 0);  -- sfix16_En15
  SIGNAL delayLineDataOut1_1              : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL coeffTableOut0_1                 : signed(15 DOWNTO 0);  -- sfix16_En16
  SIGNAL coeffTableReg0_reg_1             : vector_of_signed16(0 TO 1);  -- sfix16 [2]
  SIGNAL coeffTableReg0_3                 : signed(15 DOWNTO 0);  -- sfix16_En16
  SIGNAL finalSumValidPipe_reg_1          : std_logic_vector(0 TO 3);  -- ufix1 [4]
  SIGNAL accumulate_1                     : std_logic;
  SIGNAL accDataOut_1                     : signed(31 DOWNTO 0);  -- sfix32_En31
  SIGNAL sumOut_signed_1                  : signed(31 DOWNTO 0);  -- sfix32_En31
  SIGNAL accSwitchOut_1                   : signed(31 DOWNTO 0);  -- sfix32_En31
  SIGNAL sumOut_1                         : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL dout_im_1                        : signed(31 DOWNTO 0);  -- sfix32_En31
  SIGNAL vldOut_1                         : std_logic;

BEGIN
  u_firRdyLogic : FirRdyLogic_ST2
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dataIn_re => dataIn_re,  -- sfix16_En15
              dataIn_im => dataIn_im,  -- sfix16_En15
              validIn => validIn,
              din_re => din_re,  -- sfix16_En15
              din_im => din_im,  -- sfix16_En15
              dinVld => dinVld
              );

  u_delayLine0 : Addressable_Delay_Line_ST2
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dataIn => din_re,  -- sfix16_En15
              validIn => delayLineValidIn0,
              shiftEn => delayLineShiftEn0_1,
              rdAddr => rdAddr0_1,  -- ufix1
              delayLineEnd => delayLineEnd0,  -- sfix16_En15
              dataOut => delayLineDataOut0  -- sfix16_En15
              );

  u_delayLine1 : Addressable_Delay_Line_block_ST2
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dataIn => std_logic_vector(delayLineDataIn1_1),  -- sfix16_En15
              validIn => delayLineShiftEn1_1,
              shiftEn => delayLineShiftEn1_1,
              rdAddr => rdAddr1,  -- ufix1
              dataOut => delayLineDataOut1  -- sfix16_En15
              );

  u_filterTap0 : FilterTapSystolicPreAdd_ST2
    PORT MAP( clk => clk,
              enb => enb,
              din_re => delayLineDataOut0,  -- sfix16_En15
              preAddIn => delayLineDataOut1,  -- sfix16_En15
              coeff => std_logic_vector(coeffTableReg0_1),  -- sfix16_En16
              sumIn => std_logic_vector(accSwitchOut),  -- sfix32_En31
              sumOut => sumOut  -- sfix32_En31
              );

  u_delayLine0_1 : Addressable_Delay_Line_block1_ST2
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dataIn => din_im,  -- sfix16_En15
              validIn => delayLineValidIn0,
              shiftEn => delayLineShiftEn0_1,
              rdAddr => rdAddr0_1,  -- ufix1
              delayLineEnd => delayLineEnd0_1,  -- sfix16_En15
              dataOut => delayLineDataOut0_1  -- sfix16_En15
              );

  u_delayLine1_1 : Addressable_Delay_Line_block2_ST2
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dataIn => std_logic_vector(delayLineDataIn1_3),  -- sfix16_En15
              validIn => delayLineShiftEn1_1,
              shiftEn => delayLineShiftEn1_1,
              rdAddr => rdAddr1,  -- ufix1
              dataOut => delayLineDataOut1_1  -- sfix16_En15
              );

  u_filterTap0_1 : FilterTapSystolicPreAdd_block_ST2
    PORT MAP( clk => clk,
              enb => enb,
              din_im => delayLineDataOut0_1,  -- sfix16_En15
              preAddIn => delayLineDataOut1_1,  -- sfix16_En15
              coeff => std_logic_vector(coeffTableReg0_3),  -- sfix16_En16
              sumIn => std_logic_vector(accSwitchOut_1),  -- sfix32_En31
              sumOut => sumOut_1  -- sfix32_En31
              );

  sharingCount_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      sharingCount_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        sharingCount_1 <= nextSharingCount;
      END IF;
    END IF;
  END PROCESS sharingCount_process;


  -- Input control counter combinatorial logic
  InputControl_output : PROCESS (dinVld, sharingCount_1)
    VARIABLE add_cast : unsigned(1 DOWNTO 0);
    VARIABLE add_temp : unsigned(1 DOWNTO 0);
  BEGIN
    add_temp := to_unsigned(16#0#, 2);
    add_cast := to_unsigned(16#0#, 2);
    delayLineValidIn0 <= hdlcoder_to_stdlogic((sharingCount_1 = '0') AND (dinVld /= '0'));
    IF (dinVld /= '0') OR (sharingCount_1 > '0') THEN 
      IF sharingCount_1 = '1' THEN 
        nextSharingCount <= '0';
      ELSE 
        add_cast := '0' & sharingCount_1;
        add_temp := add_cast + to_unsigned(16#1#, 2);
        nextSharingCount <= add_temp(0);
      END IF;
    ELSE 
      nextSharingCount <= sharingCount_1;
    END IF;
    IF sharingCount_1 = '1' THEN 
      lastPhaseStrobe <= '1';
    ELSE 
      lastPhaseStrobe <= '0';
    END IF;
  END PROCESS InputControl_output;


  delayLineShiftEn0_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayLineShiftEn0_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayLineShiftEn0_1 <= lastPhaseStrobe;
      END IF;
    END IF;
  END PROCESS delayLineShiftEn0_process;


  delayLineShiftEn1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayLineShiftEn1_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayLineShiftEn1_1 <= delayLineShiftEn0_1;
      END IF;
    END IF;
  END PROCESS delayLineShiftEn1_process;


  validOutLookahead_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      validOutLookahead_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        validOutLookahead_reg(0) <= delayLineShiftEn1_1;
        validOutLookahead_reg(1 TO 4) <= validOutLookahead_reg(0 TO 3);
      END IF;
    END IF;
  END PROCESS validOutLookahead_process;

  validOutLookahead_1 <= validOutLookahead_reg(4);

  rdAddr0_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      rdAddr0_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        rdAddr0_1 <= sharingCount_1;
      END IF;
    END IF;
  END PROCESS rdAddr0_process;


  delayLineEnd0_signed <= signed(delayLineEnd0);

  delayLineDataIn1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayLineDataIn1_1 <= to_signed(16#0000#, 16);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayLineDataIn1_1 <= delayLineEnd0_signed;
      END IF;
    END IF;
  END PROCESS delayLineDataIn1_process;


  rdAddr0_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      rdAddr1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        rdAddr1 <= rdAddr0_1;
      END IF;
    END IF;
  END PROCESS rdAddr0_2_process;


  -- Coefficient table for multiplier0
  coeffTable0_output : PROCESS (rdAddr0_1)
  BEGIN
    CASE rdAddr0_1 IS
      WHEN '0' =>
        coeffTableOut0 <= to_signed(-16#08DD#, 16);
      WHEN '1' =>
        coeffTableOut0 <= to_signed(16#48CE#, 16);
      WHEN OTHERS => 
        coeffTableOut0 <= to_signed(16#0000#, 16);
    END CASE;
  END PROCESS coeffTable0_output;


  coeffTableReg0_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      coeffTableReg0_reg <= (OTHERS => to_signed(16#0000#, 16));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        coeffTableReg0_reg(0) <= coeffTableOut0;
        coeffTableReg0_reg(1) <= coeffTableReg0_reg(0);
      END IF;
    END IF;
  END PROCESS coeffTableReg0_process;

  coeffTableReg0_1 <= coeffTableReg0_reg(1);

  finalSumValidPipe_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      finalSumValidPipe_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        finalSumValidPipe_reg(0) <= rdAddr1;
        finalSumValidPipe_reg(1 TO 3) <= finalSumValidPipe_reg(0 TO 2);
      END IF;
    END IF;
  END PROCESS finalSumValidPipe_process;

  accumulate <= finalSumValidPipe_reg(3);

  accDataOut <= to_signed(0, 32);

  
  accSwitchOut <= accDataOut WHEN accumulate = '0' ELSE
      sumOut_signed;

  sumOut_signed <= signed(sumOut);

  dout_re_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      dout_re_1 <= to_signed(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' AND validOutLookahead_1 = '1' THEN
        dout_re_1 <= sumOut_signed;
      END IF;
    END IF;
  END PROCESS dout_re_process;


  dataOut_re <= std_logic_vector(dout_re_1);

  validOutLookahead_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      validOutLookahead_reg_1 <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        validOutLookahead_reg_1(0) <= delayLineShiftEn1_1;
        validOutLookahead_reg_1(1 TO 4) <= validOutLookahead_reg_1(0 TO 3);
      END IF;
    END IF;
  END PROCESS validOutLookahead_2_process;

  validOutLookahead_3 <= validOutLookahead_reg_1(4);

  delayLineEnd0_signed_1 <= signed(delayLineEnd0_1);

  delayLineDataIn1_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayLineDataIn1_3 <= to_signed(16#0000#, 16);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayLineDataIn1_3 <= delayLineEnd0_signed_1;
      END IF;
    END IF;
  END PROCESS delayLineDataIn1_2_process;


  -- Coefficient table for multiplier0
  coeffTable0_1_output : PROCESS (rdAddr0_1)
  BEGIN
    CASE rdAddr0_1 IS
      WHEN '0' =>
        coeffTableOut0_1 <= to_signed(-16#08DD#, 16);
      WHEN '1' =>
        coeffTableOut0_1 <= to_signed(16#48CE#, 16);
      WHEN OTHERS => 
        coeffTableOut0_1 <= to_signed(16#0000#, 16);
    END CASE;
  END PROCESS coeffTable0_1_output;


  coeffTableReg0_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      coeffTableReg0_reg_1 <= (OTHERS => to_signed(16#0000#, 16));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        coeffTableReg0_reg_1(0) <= coeffTableOut0_1;
        coeffTableReg0_reg_1(1) <= coeffTableReg0_reg_1(0);
      END IF;
    END IF;
  END PROCESS coeffTableReg0_2_process;

  coeffTableReg0_3 <= coeffTableReg0_reg_1(1);

  finalSumValidPipe_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      finalSumValidPipe_reg_1 <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        finalSumValidPipe_reg_1(0) <= rdAddr1;
        finalSumValidPipe_reg_1(1 TO 3) <= finalSumValidPipe_reg_1(0 TO 2);
      END IF;
    END IF;
  END PROCESS finalSumValidPipe_1_process;

  accumulate_1 <= finalSumValidPipe_reg_1(3);

  accDataOut_1 <= to_signed(0, 32);

  
  accSwitchOut_1 <= accDataOut_1 WHEN accumulate_1 = '0' ELSE
      sumOut_signed_1;

  sumOut_signed_1 <= signed(sumOut_1);

  dout_im_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      dout_im_1 <= to_signed(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' AND validOutLookahead_3 = '1' THEN
        dout_im_1 <= sumOut_signed_1;
      END IF;
    END IF;
  END PROCESS dout_im_process;


  dataOut_im <= std_logic_vector(dout_im_1);

  vldOut_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      vldOut_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        vldOut_1 <= validOutLookahead_1;
      END IF;
    END IF;
  END PROCESS vldOut_process;


  validOut <= vldOut_1;

END rtl;

