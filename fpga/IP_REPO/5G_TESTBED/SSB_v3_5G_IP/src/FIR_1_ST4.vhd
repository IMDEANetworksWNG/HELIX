-- -------------------------------------------------------------
-- 
-- File Name: hdlsrc\nrhdlSSBDetectionFR1Core\FIR_1.vhd
-- Created: 2021-11-30 14:26:21
-- 
-- Generated by MATLAB 9.10 and HDL Coder 3.18
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: FIR_1
-- Source Path: nrhdlSSBDetectionFR1Core/ssbDetectionCore/Frequency Correction and DDC/DDC/FR1/Stage 4/FIR 1
-- Hierarchy Level: 1
-- 
-- Discrete FIR Filter HDL Optimized
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.Stage_4_pkg.ALL;

ENTITY FIR_1_ST4 IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        dataIn_re                         :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
        dataIn_im                         :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
        validIn                           :   IN    std_logic;
        dataOut_re                        :   OUT   std_logic_vector(32 DOWNTO 0);  -- sfix33_En31
        dataOut_im                        :   OUT   std_logic_vector(32 DOWNTO 0);  -- sfix33_En31
        validOut                          :   OUT   std_logic
        );
END FIR_1_ST4;


ARCHITECTURE rtl OF FIR_1_ST4 IS

  -- Component Declarations
  COMPONENT FirRdyLogic_ST4
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          dataIn_re                       :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          dataIn_im                       :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          validIn                         :   IN    std_logic;
          din_re                          :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          din_im                          :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          dinVld                          :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT Addressable_Delay_Line_ST4
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          dataIn                          :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          validIn                         :   IN    std_logic;
          shiftEn                         :   IN    std_logic;
          rdAddr                          :   IN    std_logic_vector(2 DOWNTO 0);  -- ufix3
          delayLineEnd                    :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          dataOut                         :   OUT   std_logic_vector(15 DOWNTO 0)  -- sfix16_En15
          );
  END COMPONENT;

  COMPONENT Addressable_Delay_Line_block_ST4
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          dataIn                          :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          validIn                         :   IN    std_logic;
          shiftEn                         :   IN    std_logic;
          rdAddr                          :   IN    std_logic_vector(2 DOWNTO 0);  -- ufix3
          delayLineEnd                    :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          dataOut                         :   OUT   std_logic_vector(15 DOWNTO 0)  -- sfix16_En15
          );
  END COMPONENT;

  COMPONENT Addressable_Delay_Line_block1_ST4
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          dataIn                          :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          validIn                         :   IN    std_logic;
          shiftEn                         :   IN    std_logic;
          rdAddr                          :   IN    std_logic_vector(2 DOWNTO 0);  -- ufix3
          delayLineEnd                    :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          dataOut                         :   OUT   std_logic_vector(15 DOWNTO 0)  -- sfix16_En15
          );
  END COMPONENT;

  COMPONENT Addressable_Delay_Line_block2_ST4
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          dataIn                          :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          validIn                         :   IN    std_logic;
          shiftEn                         :   IN    std_logic;
          rdAddr                          :   IN    std_logic_vector(2 DOWNTO 0);  -- ufix3
          delayLineEnd                    :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          dataOut                         :   OUT   std_logic_vector(15 DOWNTO 0)  -- sfix16_En15
          );
  END COMPONENT;

  COMPONENT FilterTapSystolicPreAdd_ST4
    PORT( clk                             :   IN    std_logic;
          enb                             :   IN    std_logic;
          din_re                          :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          preAddIn                        :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          coeff                           :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En16
          sumIn                           :   IN    std_logic_vector(32 DOWNTO 0);  -- sfix33_En31
          sumOut                          :   OUT   std_logic_vector(32 DOWNTO 0)  -- sfix33_En31
          );
  END COMPONENT;

  COMPONENT Addressable_Delay_Line_block3_ST4
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          dataIn                          :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          validIn                         :   IN    std_logic;
          shiftEn                         :   IN    std_logic;
          rdAddr                          :   IN    std_logic_vector(2 DOWNTO 0);  -- ufix3
          delayLineEnd                    :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          dataOut                         :   OUT   std_logic_vector(15 DOWNTO 0)  -- sfix16_En15
          );
  END COMPONENT;

  COMPONENT Addressable_Delay_Line_block4_ST4
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          dataIn                          :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          validIn                         :   IN    std_logic;
          shiftEn                         :   IN    std_logic;
          rdAddr                          :   IN    std_logic_vector(2 DOWNTO 0);  -- ufix3
          delayLineEnd                    :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          dataOut                         :   OUT   std_logic_vector(15 DOWNTO 0)  -- sfix16_En15
          );
  END COMPONENT;

  COMPONENT Addressable_Delay_Line_block5_ST4
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          dataIn                          :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          validIn                         :   IN    std_logic;
          shiftEn                         :   IN    std_logic;
          rdAddr                          :   IN    std_logic_vector(2 DOWNTO 0);  -- ufix3
          delayLineEnd                    :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          dataOut                         :   OUT   std_logic_vector(15 DOWNTO 0)  -- sfix16_En15
          );
  END COMPONENT;

  COMPONENT Addressable_Delay_Line_block6_ST4
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          dataIn                          :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          validIn                         :   IN    std_logic;
          shiftEn                         :   IN    std_logic;
          rdAddr                          :   IN    std_logic_vector(2 DOWNTO 0);  -- ufix3
          delayLineEnd                    :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          dataOut                         :   OUT   std_logic_vector(15 DOWNTO 0)  -- sfix16_En15
          );
  END COMPONENT;

  COMPONENT FilterTapSystolicPreAdd_block_ST4
    PORT( clk                             :   IN    std_logic;
          enb                             :   IN    std_logic;
          din_im                          :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          preAddIn                        :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          coeff                           :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En16
          sumIn                           :   IN    std_logic_vector(32 DOWNTO 0);  -- sfix33_En31
          sumOut                          :   OUT   std_logic_vector(32 DOWNTO 0)  -- sfix33_En31
          );
  END COMPONENT;

--  -- Component Configuration Statements
--  FOR ALL : FirRdyLogic
--    USE ENTITY work.FirRdyLogic(rtl);

--  FOR ALL : Addressable_Delay_Line_ST2
--    USE ENTITY work.Addressable_Delay_Line_ST2(rtl);

--  FOR ALL : Addressable_Delay_Line_block_ST2
--    USE ENTITY work.Addressable_Delay_Line_block_ST2(rtl);

--  FOR ALL : Addressable_Delay_Line_block1_ST2
--    USE ENTITY work.Addressable_Delay_Line_block1_ST2(rtl);

--  FOR ALL : Addressable_Delay_Line_block2_ST2
--    USE ENTITY work.Addressable_Delay_Line_block2_ST2(rtl);

--  FOR ALL : FilterTapSystolicPreAdd
--    USE ENTITY work.FilterTapSystolicPreAdd(rtl);

--  FOR ALL : Addressable_Delay_Line_block3_ST2
--    USE ENTITY work.Addressable_Delay_Line_block3_ST2(rtl);

--  FOR ALL : Addressable_Delay_Line_block4_ST2
--    USE ENTITY work.Addressable_Delay_Line_block4_ST2(rtl);

--  FOR ALL : Addressable_Delay_Line_block5_ST2
--    USE ENTITY work.Addressable_Delay_Line_block5_ST2(rtl);

--  FOR ALL : Addressable_Delay_Line_block6_ST2
--    USE ENTITY work.Addressable_Delay_Line_block6_ST2(rtl);

--  FOR ALL : FilterTapSystolicPreAdd_block
--    USE ENTITY work.FilterTapSystolicPreAdd_block(rtl);

  -- Functions
  -- HDLCODER_TO_STDLOGIC 
  FUNCTION hdlcoder_to_stdlogic(arg: boolean) RETURN std_logic IS
  BEGIN
    IF arg THEN
      RETURN '1';
    ELSE
      RETURN '0';
    END IF;
  END FUNCTION;


  -- Signals
  SIGNAL din_re                           : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL din_im                           : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL dinVld                           : std_logic;
  SIGNAL nextSharingCount                 : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL sharingCount_1                   : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL delayLineValidIn0                : std_logic;
  SIGNAL lastPhaseStrobe                  : std_logic;
  SIGNAL delayLineShiftEn0_1              : std_logic;
  SIGNAL delayLineShiftEn1_1              : std_logic;
  SIGNAL delayLineShiftEn2_1              : std_logic;
  SIGNAL delayLineShiftEn3_1              : std_logic;
  SIGNAL delayLineShiftEn4_1              : std_logic;
  SIGNAL validOutLookahead_reg            : std_logic_vector(0 TO 6);  -- ufix1 [7]
  SIGNAL validOutLookahead_1              : std_logic;
  SIGNAL rdAddr0_1                        : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL rdAddr1                          : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL rdAddr2                          : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL rdAddr3                          : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL rdAddr4                          : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL rdAddrEndNonZero                 : std_logic;
  SIGNAL finalSumValidPipe_reg            : std_logic_vector(0 TO 5);  -- ufix1 [6]
  SIGNAL accumulate                       : std_logic;
  SIGNAL accDataOut                       : signed(32 DOWNTO 0);  -- sfix33_En31
  SIGNAL delayLineEnd0                    : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL delayLineDataOut0                : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL delayLineEnd0_signed             : signed(15 DOWNTO 0);  -- sfix16_En15
  SIGNAL delayLineDataIn1_1               : signed(15 DOWNTO 0);  -- sfix16_En15
  SIGNAL delayLineEnd1                    : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL delayLineDataOut1                : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL delayLineEnd1_signed             : signed(15 DOWNTO 0);  -- sfix16_En15
  SIGNAL delayLineDataIn2_1               : signed(15 DOWNTO 0);  -- sfix16_En15
  SIGNAL delayLineEnd2                    : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL delayLineDataOut2                : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL delayLineEnd2_signed             : signed(15 DOWNTO 0);  -- sfix16_En15
  SIGNAL delayLineDataIn3_1               : signed(15 DOWNTO 0);  -- sfix16_En15
  SIGNAL delayLineEnd3                    : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL delayLineDataOut3                : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL delayLineEnd3_signed             : signed(15 DOWNTO 0);  -- sfix16_En15
  SIGNAL delayLineDataIn4_1               : signed(15 DOWNTO 0);  -- sfix16_En15
  SIGNAL delayLineEnd4                    : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL delayLineDataOut4                : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL coeffTableOut3                   : signed(15 DOWNTO 0);  -- sfix16_En16
  SIGNAL coeffTableReg3_reg               : vector_of_signed16(0 TO 1);  -- sfix16 [2]
  SIGNAL coeffTableReg3_1                 : signed(15 DOWNTO 0);  -- sfix16_En16
  SIGNAL delayLineEnd5                    : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL delayLineDataOut5                : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL coeffTableOut2                   : signed(15 DOWNTO 0);  -- sfix16_En16
  SIGNAL coeffTableReg2_reg               : vector_of_signed16(0 TO 1);  -- sfix16 [2]
  SIGNAL coeffTableReg2_1                 : signed(15 DOWNTO 0);  -- sfix16_En16
  SIGNAL delayLineEnd6                    : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL delayLineDataOut6                : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL coeffTableOut1                   : signed(15 DOWNTO 0);  -- sfix16_En16
  SIGNAL coeffTableReg1_reg               : vector_of_signed16(0 TO 1);  -- sfix16 [2]
  SIGNAL coeffTableReg1_1                 : signed(15 DOWNTO 0);  -- sfix16_En16
  SIGNAL delayLineEnd7deadOut             : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL delayLineDataOut7                : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL coeffTableOut0                   : signed(15 DOWNTO 0);  -- sfix16_En16
  SIGNAL coeffTableReg0_reg               : vector_of_signed16(0 TO 1);  -- sfix16 [2]
  SIGNAL coeffTableReg0_1                 : signed(15 DOWNTO 0);  -- sfix16_En16
  SIGNAL sumIn                            : signed(32 DOWNTO 0);  -- sfix33_En31
  SIGNAL sumOut                           : std_logic_vector(32 DOWNTO 0);  -- ufix33
  SIGNAL sumOut_0                         : std_logic_vector(32 DOWNTO 0);  -- ufix33
  SIGNAL sumOut_1                         : std_logic_vector(32 DOWNTO 0);  -- ufix33
  SIGNAL sumOut_2                         : std_logic_vector(32 DOWNTO 0);  -- ufix33
  SIGNAL sumOut_2_signed                  : signed(32 DOWNTO 0);  -- sfix33_En31
  SIGNAL sumOutReg_1                      : signed(32 DOWNTO 0);  -- sfix33_En31
  SIGNAL accDataOut_1                     : signed(32 DOWNTO 0);  -- sfix33_En31
  SIGNAL accSwitchOut                     : signed(32 DOWNTO 0);  -- sfix33_En31
  SIGNAL accAdderOut                      : signed(32 DOWNTO 0);  -- sfix33_En31
  SIGNAL dout_re_1                        : signed(32 DOWNTO 0);  -- sfix33_En31
  SIGNAL validOutLookahead_reg_1          : std_logic_vector(0 TO 6);  -- ufix1 [7]
  SIGNAL validOutLookahead_3              : std_logic;
  SIGNAL rdAddrEndNonZero_1               : std_logic;
  SIGNAL finalSumValidPipe_reg_1          : std_logic_vector(0 TO 5);  -- ufix1 [6]
  SIGNAL accumulate_1                     : std_logic;
  SIGNAL accDataOut_3                     : signed(32 DOWNTO 0);  -- sfix33_En31
  SIGNAL delayLineEnd0_1                  : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL delayLineDataOut0_1              : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL delayLineEnd0_signed_1           : signed(15 DOWNTO 0);  -- sfix16_En15
  SIGNAL delayLineDataIn1_3               : signed(15 DOWNTO 0);  -- sfix16_En15
  SIGNAL delayLineEnd1_1                  : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL delayLineDataOut1_1              : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL delayLineEnd1_signed_1           : signed(15 DOWNTO 0);  -- sfix16_En15
  SIGNAL delayLineDataIn2_3               : signed(15 DOWNTO 0);  -- sfix16_En15
  SIGNAL delayLineEnd2_1                  : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL delayLineDataOut2_1              : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL delayLineEnd2_signed_1           : signed(15 DOWNTO 0);  -- sfix16_En15
  SIGNAL delayLineDataIn3_3               : signed(15 DOWNTO 0);  -- sfix16_En15
  SIGNAL delayLineEnd3_1                  : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL delayLineDataOut3_1              : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL delayLineEnd3_signed_1           : signed(15 DOWNTO 0);  -- sfix16_En15
  SIGNAL delayLineDataIn4_3               : signed(15 DOWNTO 0);  -- sfix16_En15
  SIGNAL delayLineEnd4_1                  : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL delayLineDataOut4_1              : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL coeffTableOut3_1                 : signed(15 DOWNTO 0);  -- sfix16_En16
  SIGNAL coeffTableReg3_reg_1             : vector_of_signed16(0 TO 1);  -- sfix16 [2]
  SIGNAL coeffTableReg3_3                 : signed(15 DOWNTO 0);  -- sfix16_En16
  SIGNAL delayLineEnd5_1                  : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL delayLineDataOut5_1              : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL coeffTableOut2_1                 : signed(15 DOWNTO 0);  -- sfix16_En16
  SIGNAL coeffTableReg2_reg_1             : vector_of_signed16(0 TO 1);  -- sfix16 [2]
  SIGNAL coeffTableReg2_3                 : signed(15 DOWNTO 0);  -- sfix16_En16
  SIGNAL delayLineEnd6_1                  : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL delayLineDataOut6_1              : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL coeffTableOut1_1                 : signed(15 DOWNTO 0);  -- sfix16_En16
  SIGNAL coeffTableReg1_reg_1             : vector_of_signed16(0 TO 1);  -- sfix16 [2]
  SIGNAL coeffTableReg1_3                 : signed(15 DOWNTO 0);  -- sfix16_En16
  SIGNAL delayLineEnd7deadOut_1           : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL delayLineDataOut7_1              : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL coeffTableOut0_1                 : signed(15 DOWNTO 0);  -- sfix16_En16
  SIGNAL coeffTableReg0_reg_1             : vector_of_signed16(0 TO 1);  -- sfix16 [2]
  SIGNAL coeffTableReg0_3                 : signed(15 DOWNTO 0);  -- sfix16_En16
  SIGNAL sumIn_1                          : signed(32 DOWNTO 0);  -- sfix33_En31
  SIGNAL sumOut_3                         : std_logic_vector(32 DOWNTO 0);  -- ufix33
  SIGNAL sumOut_0_1                       : std_logic_vector(32 DOWNTO 0);  -- ufix33
  SIGNAL sumOut_1_1                       : std_logic_vector(32 DOWNTO 0);  -- ufix33
  SIGNAL sumOut_2_1                       : std_logic_vector(32 DOWNTO 0);  -- ufix33
  SIGNAL sumOut_2_signed_1                : signed(32 DOWNTO 0);  -- sfix33_En31
  SIGNAL sumOutReg_3                      : signed(32 DOWNTO 0);  -- sfix33_En31
  SIGNAL accDataOut_4                     : signed(32 DOWNTO 0);  -- sfix33_En31
  SIGNAL accSwitchOut_1                   : signed(32 DOWNTO 0);  -- sfix33_En31
  SIGNAL accAdderOut_1                    : signed(32 DOWNTO 0);  -- sfix33_En31
  SIGNAL dout_im_1                        : signed(32 DOWNTO 0);  -- sfix33_En31
  SIGNAL vldOut_1                         : std_logic;

BEGIN
  u_firRdyLogic : FirRdyLogic_ST4
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dataIn_re => dataIn_re,  -- sfix16_En15
              dataIn_im => dataIn_im,  -- sfix16_En15
              validIn => validIn,
              din_re => din_re,  -- sfix16_En15
              din_im => din_im,  -- sfix16_En15
              dinVld => dinVld
              );

  u_delayLine0 : Addressable_Delay_Line_ST4
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dataIn => din_re,  -- sfix16_En15
              validIn => delayLineValidIn0,
              shiftEn => delayLineShiftEn0_1,
              rdAddr => std_logic_vector(rdAddr0_1),  -- ufix3
              delayLineEnd => delayLineEnd0,  -- sfix16_En15
              dataOut => delayLineDataOut0  -- sfix16_En15
              );

  u_delayLine1 : Addressable_Delay_Line_ST4
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dataIn => std_logic_vector(delayLineDataIn1_1),  -- sfix16_En15
              validIn => delayLineShiftEn1_1,
              shiftEn => delayLineShiftEn1_1,
              rdAddr => std_logic_vector(rdAddr1),  -- ufix3
              delayLineEnd => delayLineEnd1,  -- sfix16_En15
              dataOut => delayLineDataOut1  -- sfix16_En15
              );

  u_delayLine2 : Addressable_Delay_Line_ST4
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dataIn => std_logic_vector(delayLineDataIn2_1),  -- sfix16_En15
              validIn => delayLineShiftEn2_1,
              shiftEn => delayLineShiftEn2_1,
              rdAddr => std_logic_vector(rdAddr2),  -- ufix3
              delayLineEnd => delayLineEnd2,  -- sfix16_En15
              dataOut => delayLineDataOut2  -- sfix16_En15
              );

  u_delayLine3 : Addressable_Delay_Line_block_ST4
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dataIn => std_logic_vector(delayLineDataIn3_1),  -- sfix16_En15
              validIn => delayLineShiftEn3_1,
              shiftEn => delayLineShiftEn3_1,
              rdAddr => std_logic_vector(rdAddr3),  -- ufix3
              delayLineEnd => delayLineEnd3,  -- sfix16_En15
              dataOut => delayLineDataOut3  -- sfix16_En15
              );

  u_delayLine4 : Addressable_Delay_Line_block1_ST4
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dataIn => std_logic_vector(delayLineDataIn4_1),  -- sfix16_En15
              validIn => delayLineShiftEn4_1,
              shiftEn => delayLineShiftEn4_1,
              rdAddr => std_logic_vector(rdAddr4),  -- ufix3
              delayLineEnd => delayLineEnd4,  -- sfix16_En15
              dataOut => delayLineDataOut4  -- sfix16_En15
              );

  u_delayLine5 : Addressable_Delay_Line_block2_ST4
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dataIn => delayLineEnd4,  -- sfix16_En15
              validIn => delayLineShiftEn3_1,
              shiftEn => delayLineShiftEn3_1,
              rdAddr => std_logic_vector(rdAddr3),  -- ufix3
              delayLineEnd => delayLineEnd5,  -- sfix16_En15
              dataOut => delayLineDataOut5  -- sfix16_En15
              );

  u_delayLine6 : Addressable_Delay_Line_block2_ST4
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dataIn => delayLineEnd5,  -- sfix16_En15
              validIn => delayLineShiftEn2_1,
              shiftEn => delayLineShiftEn2_1,
              rdAddr => std_logic_vector(rdAddr2),  -- ufix3
              delayLineEnd => delayLineEnd6,  -- sfix16_En15
              dataOut => delayLineDataOut6  -- sfix16_En15
              );

  u_delayLine7 : Addressable_Delay_Line_block2_ST4
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dataIn => delayLineEnd6,  -- sfix16_En15
              validIn => delayLineShiftEn1_1,
              shiftEn => delayLineShiftEn1_1,
              rdAddr => std_logic_vector(rdAddr1),  -- ufix3
              delayLineEnd => delayLineEnd7deadOut,  -- sfix16_En15
              dataOut => delayLineDataOut7  -- sfix16_En15
              );

  u_filterTap0 : FilterTapSystolicPreAdd_ST4
    PORT MAP( clk => clk,
              enb => enb,
              din_re => delayLineDataOut0,  -- sfix16_En15
              preAddIn => delayLineDataOut7,  -- sfix16_En15
              coeff => std_logic_vector(coeffTableReg0_1),  -- sfix16_En16
              sumIn => std_logic_vector(sumIn),  -- sfix33_En31
              sumOut => sumOut  -- sfix33_En31
              );

  u_filterTap1 : FilterTapSystolicPreAdd_ST4
    PORT MAP( clk => clk,
              enb => enb,
              din_re => delayLineDataOut1,  -- sfix16_En15
              preAddIn => delayLineDataOut6,  -- sfix16_En15
              coeff => std_logic_vector(coeffTableReg1_1),  -- sfix16_En16
              sumIn => sumOut,  -- sfix33_En31
              sumOut => sumOut_0  -- sfix33_En31
              );

  u_filterTap2 : FilterTapSystolicPreAdd_ST4
    PORT MAP( clk => clk,
              enb => enb,
              din_re => delayLineDataOut2,  -- sfix16_En15
              preAddIn => delayLineDataOut5,  -- sfix16_En15
              coeff => std_logic_vector(coeffTableReg2_1),  -- sfix16_En16
              sumIn => sumOut_0,  -- sfix33_En31
              sumOut => sumOut_1  -- sfix33_En31
              );

  u_filterTap3 : FilterTapSystolicPreAdd_ST4
    PORT MAP( clk => clk,
              enb => enb,
              din_re => delayLineDataOut3,  -- sfix16_En15
              preAddIn => delayLineDataOut4,  -- sfix16_En15
              coeff => std_logic_vector(coeffTableReg3_1),  -- sfix16_En16
              sumIn => sumOut_1,  -- sfix33_En31
              sumOut => sumOut_2  -- sfix33_En31
              );

  u_delayLine0_1 : Addressable_Delay_Line_block3_ST4
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dataIn => din_im,  -- sfix16_En15
              validIn => delayLineValidIn0,
              shiftEn => delayLineShiftEn0_1,
              rdAddr => std_logic_vector(rdAddr0_1),  -- ufix3
              delayLineEnd => delayLineEnd0_1,  -- sfix16_En15
              dataOut => delayLineDataOut0_1  -- sfix16_En15
              );

  u_delayLine1_1 : Addressable_Delay_Line_block3_ST4
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dataIn => std_logic_vector(delayLineDataIn1_3),  -- sfix16_En15
              validIn => delayLineShiftEn1_1,
              shiftEn => delayLineShiftEn1_1,
              rdAddr => std_logic_vector(rdAddr1),  -- ufix3
              delayLineEnd => delayLineEnd1_1,  -- sfix16_En15
              dataOut => delayLineDataOut1_1  -- sfix16_En15
              );

  u_delayLine2_1 : Addressable_Delay_Line_block3_ST4
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dataIn => std_logic_vector(delayLineDataIn2_3),  -- sfix16_En15
              validIn => delayLineShiftEn2_1,
              shiftEn => delayLineShiftEn2_1,
              rdAddr => std_logic_vector(rdAddr2),  -- ufix3
              delayLineEnd => delayLineEnd2_1,  -- sfix16_En15
              dataOut => delayLineDataOut2_1  -- sfix16_En15
              );

  u_delayLine3_1 : Addressable_Delay_Line_block4_ST4
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dataIn => std_logic_vector(delayLineDataIn3_3),  -- sfix16_En15
              validIn => delayLineShiftEn3_1,
              shiftEn => delayLineShiftEn3_1,
              rdAddr => std_logic_vector(rdAddr3),  -- ufix3
              delayLineEnd => delayLineEnd3_1,  -- sfix16_En15
              dataOut => delayLineDataOut3_1  -- sfix16_En15
              );

  u_delayLine4_1 : Addressable_Delay_Line_block5_ST4
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dataIn => std_logic_vector(delayLineDataIn4_3),  -- sfix16_En15
              validIn => delayLineShiftEn4_1,
              shiftEn => delayLineShiftEn4_1,
              rdAddr => std_logic_vector(rdAddr4),  -- ufix3
              delayLineEnd => delayLineEnd4_1,  -- sfix16_En15
              dataOut => delayLineDataOut4_1  -- sfix16_En15
              );

  u_delayLine5_1 : Addressable_Delay_Line_block6_ST4
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dataIn => delayLineEnd4_1,  -- sfix16_En15
              validIn => delayLineShiftEn3_1,
              shiftEn => delayLineShiftEn3_1,
              rdAddr => std_logic_vector(rdAddr3),  -- ufix3
              delayLineEnd => delayLineEnd5_1,  -- sfix16_En15
              dataOut => delayLineDataOut5_1  -- sfix16_En15
              );

  u_delayLine6_1 : Addressable_Delay_Line_block6_ST4
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dataIn => delayLineEnd5_1,  -- sfix16_En15
              validIn => delayLineShiftEn2_1,
              shiftEn => delayLineShiftEn2_1,
              rdAddr => std_logic_vector(rdAddr2),  -- ufix3
              delayLineEnd => delayLineEnd6_1,  -- sfix16_En15
              dataOut => delayLineDataOut6_1  -- sfix16_En15
              );

  u_delayLine7_1 : Addressable_Delay_Line_block6_ST4
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dataIn => delayLineEnd6_1,  -- sfix16_En15
              validIn => delayLineShiftEn1_1,
              shiftEn => delayLineShiftEn1_1,
              rdAddr => std_logic_vector(rdAddr1),  -- ufix3
              delayLineEnd => delayLineEnd7deadOut_1,  -- sfix16_En15
              dataOut => delayLineDataOut7_1  -- sfix16_En15
              );

  u_filterTap0_1 : FilterTapSystolicPreAdd_block_ST4
    PORT MAP( clk => clk,
              enb => enb,
              din_im => delayLineDataOut0_1,  -- sfix16_En15
              preAddIn => delayLineDataOut7_1,  -- sfix16_En15
              coeff => std_logic_vector(coeffTableReg0_3),  -- sfix16_En16
              sumIn => std_logic_vector(sumIn_1),  -- sfix33_En31
              sumOut => sumOut_3  -- sfix33_En31
              );

  u_filterTap1_1 : FilterTapSystolicPreAdd_block_ST4
    PORT MAP( clk => clk,
              enb => enb,
              din_im => delayLineDataOut1_1,  -- sfix16_En15
              preAddIn => delayLineDataOut6_1,  -- sfix16_En15
              coeff => std_logic_vector(coeffTableReg1_3),  -- sfix16_En16
              sumIn => sumOut_3,  -- sfix33_En31
              sumOut => sumOut_0_1  -- sfix33_En31
              );

  u_filterTap2_1 : FilterTapSystolicPreAdd_block_ST4
    PORT MAP( clk => clk,
              enb => enb,
              din_im => delayLineDataOut2_1,  -- sfix16_En15
              preAddIn => delayLineDataOut5_1,  -- sfix16_En15
              coeff => std_logic_vector(coeffTableReg2_3),  -- sfix16_En16
              sumIn => sumOut_0_1,  -- sfix33_En31
              sumOut => sumOut_1_1  -- sfix33_En31
              );

  u_filterTap3_1 : FilterTapSystolicPreAdd_block_ST4
    PORT MAP( clk => clk,
              enb => enb,
              din_im => delayLineDataOut3_1,  -- sfix16_En15
              preAddIn => delayLineDataOut4_1,  -- sfix16_En15
              coeff => std_logic_vector(coeffTableReg3_3),  -- sfix16_En16
              sumIn => sumOut_1_1,  -- sfix33_En31
              sumOut => sumOut_2_1  -- sfix33_En31
              );

  sharingCount_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      sharingCount_1 <= to_unsigned(16#0#, 3);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        sharingCount_1 <= nextSharingCount;
      END IF;
    END IF;
  END PROCESS sharingCount_process;


  -- Input control counter combinatorial logic
  InputControl_output : PROCESS (dinVld, sharingCount_1)
  BEGIN
    delayLineValidIn0 <= hdlcoder_to_stdlogic((sharingCount_1 = to_unsigned(16#0#, 3)) AND (dinVld /= '0'));
    IF (dinVld /= '0') OR (sharingCount_1 > to_unsigned(16#0#, 3)) THEN 
      IF sharingCount_1 = to_unsigned(16#7#, 3) THEN 
        nextSharingCount <= to_unsigned(16#0#, 3);
      ELSE 
        nextSharingCount <= sharingCount_1 + to_unsigned(16#1#, 3);
      END IF;
    ELSE 
      nextSharingCount <= sharingCount_1;
    END IF;
    IF sharingCount_1 = to_unsigned(16#6#, 3) THEN 
      lastPhaseStrobe <= '1';
    ELSE 
      lastPhaseStrobe <= '0';
    END IF;
  END PROCESS InputControl_output;


  delayLineShiftEn0_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayLineShiftEn0_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayLineShiftEn0_1 <= lastPhaseStrobe;
      END IF;
    END IF;
  END PROCESS delayLineShiftEn0_process;


  delayLineShiftEn1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayLineShiftEn1_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayLineShiftEn1_1 <= delayLineShiftEn0_1;
      END IF;
    END IF;
  END PROCESS delayLineShiftEn1_process;


  delayLineShiftEn2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayLineShiftEn2_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayLineShiftEn2_1 <= delayLineShiftEn1_1;
      END IF;
    END IF;
  END PROCESS delayLineShiftEn2_process;


  delayLineShiftEn3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayLineShiftEn3_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayLineShiftEn3_1 <= delayLineShiftEn2_1;
      END IF;
    END IF;
  END PROCESS delayLineShiftEn3_process;


  delayLineShiftEn4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayLineShiftEn4_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayLineShiftEn4_1 <= delayLineShiftEn3_1;
      END IF;
    END IF;
  END PROCESS delayLineShiftEn4_process;


  validOutLookahead_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      validOutLookahead_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        validOutLookahead_reg(0) <= delayLineShiftEn4_1;
        validOutLookahead_reg(1 TO 6) <= validOutLookahead_reg(0 TO 5);
      END IF;
    END IF;
  END PROCESS validOutLookahead_process;

  validOutLookahead_1 <= validOutLookahead_reg(6);

  rdAddr0_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      rdAddr0_1 <= to_unsigned(16#0#, 3);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        rdAddr0_1 <= sharingCount_1;
      END IF;
    END IF;
  END PROCESS rdAddr0_process;


  rdAddr0_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      rdAddr1 <= to_unsigned(16#0#, 3);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        rdAddr1 <= rdAddr0_1;
      END IF;
    END IF;
  END PROCESS rdAddr0_2_process;


  rdAddr1_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      rdAddr2 <= to_unsigned(16#0#, 3);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        rdAddr2 <= rdAddr1;
      END IF;
    END IF;
  END PROCESS rdAddr1_1_process;


  rdAddr2_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      rdAddr3 <= to_unsigned(16#0#, 3);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        rdAddr3 <= rdAddr2;
      END IF;
    END IF;
  END PROCESS rdAddr2_1_process;


  rdAddr3_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      rdAddr4 <= to_unsigned(16#0#, 3);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        rdAddr4 <= rdAddr3;
      END IF;
    END IF;
  END PROCESS rdAddr3_1_process;


  
  rdAddrEndNonZero <= '1' WHEN rdAddr4 /= to_unsigned(16#0#, 3) ELSE
      '0';

  finalSumValidPipe_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      finalSumValidPipe_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        finalSumValidPipe_reg(0) <= rdAddrEndNonZero;
        finalSumValidPipe_reg(1 TO 5) <= finalSumValidPipe_reg(0 TO 4);
      END IF;
    END IF;
  END PROCESS finalSumValidPipe_process;

  accumulate <= finalSumValidPipe_reg(5);

  accDataOut <= to_signed(0, 33);

  delayLineEnd0_signed <= signed(delayLineEnd0);

  delayLineDataIn1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayLineDataIn1_1 <= to_signed(16#0000#, 16);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayLineDataIn1_1 <= delayLineEnd0_signed;
      END IF;
    END IF;
  END PROCESS delayLineDataIn1_process;


  delayLineEnd1_signed <= signed(delayLineEnd1);

  delayLineDataIn2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayLineDataIn2_1 <= to_signed(16#0000#, 16);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayLineDataIn2_1 <= delayLineEnd1_signed;
      END IF;
    END IF;
  END PROCESS delayLineDataIn2_process;


  delayLineEnd2_signed <= signed(delayLineEnd2);

  delayLineDataIn3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayLineDataIn3_1 <= to_signed(16#0000#, 16);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayLineDataIn3_1 <= delayLineEnd2_signed;
      END IF;
    END IF;
  END PROCESS delayLineDataIn3_process;


  delayLineEnd3_signed <= signed(delayLineEnd3);

  delayLineDataIn4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayLineDataIn4_1 <= to_signed(16#0000#, 16);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayLineDataIn4_1 <= delayLineEnd3_signed;
      END IF;
    END IF;
  END PROCESS delayLineDataIn4_process;


  -- Coefficient table for multiplier3
  coeffTable3_output : PROCESS (rdAddr3)
  BEGIN
    CASE rdAddr3 IS
      WHEN "000" =>
        coeffTableOut3 <= to_signed(-16#06C0#, 16);
      WHEN "001" =>
        coeffTableOut3 <= to_signed(16#0882#, 16);
      WHEN "010" =>
        coeffTableOut3 <= to_signed(-16#0B37#, 16);
      WHEN "011" =>
        coeffTableOut3 <= to_signed(16#0FFD#, 16);
      WHEN "100" =>
        coeffTableOut3 <= to_signed(-16#1AFA#, 16);
      WHEN "101" =>
        coeffTableOut3 <= to_signed(16#516D#, 16);
      WHEN "110" =>
        coeffTableOut3 <= to_signed(16#0000#, 16);
      WHEN OTHERS => 
        coeffTableOut3 <= to_signed(16#0000#, 16);
    END CASE;
  END PROCESS coeffTable3_output;


  coeffTableReg3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      coeffTableReg3_reg <= (OTHERS => to_signed(16#0000#, 16));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        coeffTableReg3_reg(0) <= coeffTableOut3;
        coeffTableReg3_reg(1) <= coeffTableReg3_reg(0);
      END IF;
    END IF;
  END PROCESS coeffTableReg3_process;

  coeffTableReg3_1 <= coeffTableReg3_reg(1);

  -- Coefficient table for multiplier2
  coeffTable2_output : PROCESS (rdAddr2)
  BEGIN
    CASE rdAddr2 IS
      WHEN "000" =>
        coeffTableOut2 <= to_signed(16#01FB#, 16);
      WHEN "001" =>
        coeffTableOut2 <= to_signed(-16#0255#, 16);
      WHEN "010" =>
        coeffTableOut2 <= to_signed(16#02BE#, 16);
      WHEN "011" =>
        coeffTableOut2 <= to_signed(-16#033C#, 16);
      WHEN "100" =>
        coeffTableOut2 <= to_signed(16#03D4#, 16);
      WHEN "101" =>
        coeffTableOut2 <= to_signed(-16#0490#, 16);
      WHEN "110" =>
        coeffTableOut2 <= to_signed(16#0581#, 16);
      WHEN OTHERS => 
        coeffTableOut2 <= to_signed(16#0000#, 16);
    END CASE;
  END PROCESS coeffTable2_output;


  coeffTableReg2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      coeffTableReg2_reg <= (OTHERS => to_signed(16#0000#, 16));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        coeffTableReg2_reg(0) <= coeffTableOut2;
        coeffTableReg2_reg(1) <= coeffTableReg2_reg(0);
      END IF;
    END IF;
  END PROCESS coeffTableReg2_process;

  coeffTableReg2_1 <= coeffTableReg2_reg(1);

  -- Coefficient table for multiplier1
  coeffTable1_output : PROCESS (rdAddr1)
  BEGIN
    CASE rdAddr1 IS
      WHEN "000" =>
        coeffTableOut1 <= to_signed(-16#0090#, 16);
      WHEN "001" =>
        coeffTableOut1 <= to_signed(16#00B0#, 16);
      WHEN "010" =>
        coeffTableOut1 <= to_signed(-16#00D6#, 16);
      WHEN "011" =>
        coeffTableOut1 <= to_signed(16#0101#, 16);
      WHEN "100" =>
        coeffTableOut1 <= to_signed(-16#0132#, 16);
      WHEN "101" =>
        coeffTableOut1 <= to_signed(16#016C#, 16);
      WHEN "110" =>
        coeffTableOut1 <= to_signed(-16#01AE#, 16);
      WHEN OTHERS => 
        coeffTableOut1 <= to_signed(16#0000#, 16);
    END CASE;
  END PROCESS coeffTable1_output;


  coeffTableReg1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      coeffTableReg1_reg <= (OTHERS => to_signed(16#0000#, 16));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        coeffTableReg1_reg(0) <= coeffTableOut1;
        coeffTableReg1_reg(1) <= coeffTableReg1_reg(0);
      END IF;
    END IF;
  END PROCESS coeffTableReg1_process;

  coeffTableReg1_1 <= coeffTableReg1_reg(1);

  -- Coefficient table for multiplier0
  coeffTable0_output : PROCESS (rdAddr0_1)
  BEGIN
    CASE rdAddr0_1 IS
      WHEN "000" =>
        coeffTableOut0 <= to_signed(16#002A#, 16);
      WHEN "001" =>
        coeffTableOut0 <= to_signed(-16#001F#, 16);
      WHEN "010" =>
        coeffTableOut0 <= to_signed(16#002B#, 16);
      WHEN "011" =>
        coeffTableOut0 <= to_signed(-16#0039#, 16);
      WHEN "100" =>
        coeffTableOut0 <= to_signed(16#0049#, 16);
      WHEN "101" =>
        coeffTableOut0 <= to_signed(-16#005D#, 16);
      WHEN "110" =>
        coeffTableOut0 <= to_signed(16#0075#, 16);
      WHEN OTHERS => 
        coeffTableOut0 <= to_signed(16#0000#, 16);
    END CASE;
  END PROCESS coeffTable0_output;


  coeffTableReg0_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      coeffTableReg0_reg <= (OTHERS => to_signed(16#0000#, 16));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        coeffTableReg0_reg(0) <= coeffTableOut0;
        coeffTableReg0_reg(1) <= coeffTableReg0_reg(0);
      END IF;
    END IF;
  END PROCESS coeffTableReg0_process;

  coeffTableReg0_1 <= coeffTableReg0_reg(1);

  sumIn <= to_signed(0, 33);

  sumOut_2_signed <= signed(sumOut_2);

  sumOutReg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      sumOutReg_1 <= to_signed(0, 33);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        sumOutReg_1 <= sumOut_2_signed;
      END IF;
    END IF;
  END PROCESS sumOutReg_process;


  
  accSwitchOut <= accDataOut WHEN accumulate = '0' ELSE
      accDataOut_1;

  accAdderOut <= accSwitchOut + sumOutReg_1;

  accDataOut_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      accDataOut_1 <= to_signed(0, 33);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        accDataOut_1 <= accAdderOut;
      END IF;
    END IF;
  END PROCESS accDataOut_2_process;


  dout_re_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      dout_re_1 <= to_signed(0, 33);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' AND validOutLookahead_1 = '1' THEN
        dout_re_1 <= accDataOut_1;
      END IF;
    END IF;
  END PROCESS dout_re_process;


  dataOut_re <= std_logic_vector(dout_re_1);

  validOutLookahead_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      validOutLookahead_reg_1 <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        validOutLookahead_reg_1(0) <= delayLineShiftEn4_1;
        validOutLookahead_reg_1(1 TO 6) <= validOutLookahead_reg_1(0 TO 5);
      END IF;
    END IF;
  END PROCESS validOutLookahead_2_process;

  validOutLookahead_3 <= validOutLookahead_reg_1(6);

  
  rdAddrEndNonZero_1 <= '1' WHEN rdAddr4 /= to_unsigned(16#0#, 3) ELSE
      '0';

  finalSumValidPipe_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      finalSumValidPipe_reg_1 <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        finalSumValidPipe_reg_1(0) <= rdAddrEndNonZero_1;
        finalSumValidPipe_reg_1(1 TO 5) <= finalSumValidPipe_reg_1(0 TO 4);
      END IF;
    END IF;
  END PROCESS finalSumValidPipe_1_process;

  accumulate_1 <= finalSumValidPipe_reg_1(5);

  accDataOut_3 <= to_signed(0, 33);

  delayLineEnd0_signed_1 <= signed(delayLineEnd0_1);

  delayLineDataIn1_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayLineDataIn1_3 <= to_signed(16#0000#, 16);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayLineDataIn1_3 <= delayLineEnd0_signed_1;
      END IF;
    END IF;
  END PROCESS delayLineDataIn1_2_process;


  delayLineEnd1_signed_1 <= signed(delayLineEnd1_1);

  delayLineDataIn2_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayLineDataIn2_3 <= to_signed(16#0000#, 16);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayLineDataIn2_3 <= delayLineEnd1_signed_1;
      END IF;
    END IF;
  END PROCESS delayLineDataIn2_2_process;


  delayLineEnd2_signed_1 <= signed(delayLineEnd2_1);

  delayLineDataIn3_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayLineDataIn3_3 <= to_signed(16#0000#, 16);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayLineDataIn3_3 <= delayLineEnd2_signed_1;
      END IF;
    END IF;
  END PROCESS delayLineDataIn3_2_process;


  delayLineEnd3_signed_1 <= signed(delayLineEnd3_1);

  delayLineDataIn4_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayLineDataIn4_3 <= to_signed(16#0000#, 16);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayLineDataIn4_3 <= delayLineEnd3_signed_1;
      END IF;
    END IF;
  END PROCESS delayLineDataIn4_2_process;


  -- Coefficient table for multiplier3
  coeffTable3_1_output : PROCESS (rdAddr3)
  BEGIN
    CASE rdAddr3 IS
      WHEN "000" =>
        coeffTableOut3_1 <= to_signed(-16#06C0#, 16);
      WHEN "001" =>
        coeffTableOut3_1 <= to_signed(16#0882#, 16);
      WHEN "010" =>
        coeffTableOut3_1 <= to_signed(-16#0B37#, 16);
      WHEN "011" =>
        coeffTableOut3_1 <= to_signed(16#0FFD#, 16);
      WHEN "100" =>
        coeffTableOut3_1 <= to_signed(-16#1AFA#, 16);
      WHEN "101" =>
        coeffTableOut3_1 <= to_signed(16#516D#, 16);
      WHEN "110" =>
        coeffTableOut3_1 <= to_signed(16#0000#, 16);
      WHEN OTHERS => 
        coeffTableOut3_1 <= to_signed(16#0000#, 16);
    END CASE;
  END PROCESS coeffTable3_1_output;


  coeffTableReg3_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      coeffTableReg3_reg_1 <= (OTHERS => to_signed(16#0000#, 16));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        coeffTableReg3_reg_1(0) <= coeffTableOut3_1;
        coeffTableReg3_reg_1(1) <= coeffTableReg3_reg_1(0);
      END IF;
    END IF;
  END PROCESS coeffTableReg3_2_process;

  coeffTableReg3_3 <= coeffTableReg3_reg_1(1);

  -- Coefficient table for multiplier2
  coeffTable2_1_output : PROCESS (rdAddr2)
  BEGIN
    CASE rdAddr2 IS
      WHEN "000" =>
        coeffTableOut2_1 <= to_signed(16#01FB#, 16);
      WHEN "001" =>
        coeffTableOut2_1 <= to_signed(-16#0255#, 16);
      WHEN "010" =>
        coeffTableOut2_1 <= to_signed(16#02BE#, 16);
      WHEN "011" =>
        coeffTableOut2_1 <= to_signed(-16#033C#, 16);
      WHEN "100" =>
        coeffTableOut2_1 <= to_signed(16#03D4#, 16);
      WHEN "101" =>
        coeffTableOut2_1 <= to_signed(-16#0490#, 16);
      WHEN "110" =>
        coeffTableOut2_1 <= to_signed(16#0581#, 16);
      WHEN OTHERS => 
        coeffTableOut2_1 <= to_signed(16#0000#, 16);
    END CASE;
  END PROCESS coeffTable2_1_output;


  coeffTableReg2_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      coeffTableReg2_reg_1 <= (OTHERS => to_signed(16#0000#, 16));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        coeffTableReg2_reg_1(0) <= coeffTableOut2_1;
        coeffTableReg2_reg_1(1) <= coeffTableReg2_reg_1(0);
      END IF;
    END IF;
  END PROCESS coeffTableReg2_2_process;

  coeffTableReg2_3 <= coeffTableReg2_reg_1(1);

  -- Coefficient table for multiplier1
  coeffTable1_1_output : PROCESS (rdAddr1)
  BEGIN
    CASE rdAddr1 IS
      WHEN "000" =>
        coeffTableOut1_1 <= to_signed(-16#0090#, 16);
      WHEN "001" =>
        coeffTableOut1_1 <= to_signed(16#00B0#, 16);
      WHEN "010" =>
        coeffTableOut1_1 <= to_signed(-16#00D6#, 16);
      WHEN "011" =>
        coeffTableOut1_1 <= to_signed(16#0101#, 16);
      WHEN "100" =>
        coeffTableOut1_1 <= to_signed(-16#0132#, 16);
      WHEN "101" =>
        coeffTableOut1_1 <= to_signed(16#016C#, 16);
      WHEN "110" =>
        coeffTableOut1_1 <= to_signed(-16#01AE#, 16);
      WHEN OTHERS => 
        coeffTableOut1_1 <= to_signed(16#0000#, 16);
    END CASE;
  END PROCESS coeffTable1_1_output;


  coeffTableReg1_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      coeffTableReg1_reg_1 <= (OTHERS => to_signed(16#0000#, 16));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        coeffTableReg1_reg_1(0) <= coeffTableOut1_1;
        coeffTableReg1_reg_1(1) <= coeffTableReg1_reg_1(0);
      END IF;
    END IF;
  END PROCESS coeffTableReg1_2_process;

  coeffTableReg1_3 <= coeffTableReg1_reg_1(1);

  -- Coefficient table for multiplier0
  coeffTable0_1_output : PROCESS (rdAddr0_1)
  BEGIN
    CASE rdAddr0_1 IS
      WHEN "000" =>
        coeffTableOut0_1 <= to_signed(16#002A#, 16);
      WHEN "001" =>
        coeffTableOut0_1 <= to_signed(-16#001F#, 16);
      WHEN "010" =>
        coeffTableOut0_1 <= to_signed(16#002B#, 16);
      WHEN "011" =>
        coeffTableOut0_1 <= to_signed(-16#0039#, 16);
      WHEN "100" =>
        coeffTableOut0_1 <= to_signed(16#0049#, 16);
      WHEN "101" =>
        coeffTableOut0_1 <= to_signed(-16#005D#, 16);
      WHEN "110" =>
        coeffTableOut0_1 <= to_signed(16#0075#, 16);
      WHEN OTHERS => 
        coeffTableOut0_1 <= to_signed(16#0000#, 16);
    END CASE;
  END PROCESS coeffTable0_1_output;


  coeffTableReg0_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      coeffTableReg0_reg_1 <= (OTHERS => to_signed(16#0000#, 16));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        coeffTableReg0_reg_1(0) <= coeffTableOut0_1;
        coeffTableReg0_reg_1(1) <= coeffTableReg0_reg_1(0);
      END IF;
    END IF;
  END PROCESS coeffTableReg0_2_process;

  coeffTableReg0_3 <= coeffTableReg0_reg_1(1);

  sumIn_1 <= to_signed(0, 33);

  sumOut_2_signed_1 <= signed(sumOut_2_1);

  sumOutReg_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      sumOutReg_3 <= to_signed(0, 33);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        sumOutReg_3 <= sumOut_2_signed_1;
      END IF;
    END IF;
  END PROCESS sumOutReg_2_process;


  
  accSwitchOut_1 <= accDataOut_3 WHEN accumulate_1 = '0' ELSE
      accDataOut_4;

  accAdderOut_1 <= accSwitchOut_1 + sumOutReg_3;

  accDataOut_5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      accDataOut_4 <= to_signed(0, 33);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        accDataOut_4 <= accAdderOut_1;
      END IF;
    END IF;
  END PROCESS accDataOut_5_process;


  dout_im_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      dout_im_1 <= to_signed(0, 33);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' AND validOutLookahead_3 = '1' THEN
        dout_im_1 <= accDataOut_4;
      END IF;
    END IF;
  END PROCESS dout_im_process;


  dataOut_im <= std_logic_vector(dout_im_1);

  vldOut_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      vldOut_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        vldOut_1 <= validOutLookahead_1;
      END IF;
    END IF;
  END PROCESS vldOut_process;


  validOut <= vldOut_1;

END rtl;

